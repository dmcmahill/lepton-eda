@node lepton-schematic, lepton-netlist, Symbols, Top
@chapter Schematic capture
@cindex lepton-schematic
@cindex schematic capture

@menu
* Introduction to lepton-schematic::
* Running lepton-schematic::
* lepton-schematic window::
* Dialog boxes::
* Selecting objects::
* lepton-schematic command line options::
* Component libraries::
@end menu

@node Introduction to lepton-schematic, Running lepton-schematic, lepton-schematic, lepton-schematic
@section Introduction to lepton-schematic
@cindex lepton-schematic, introduction
@cindex introduction to lepton-schematic

@schematic{} is a @dfn{schematic capture} application in the Lepton
toolset.  It is mostly used for interactive creation of electronic
@dfn{schematics} and @dfn{symbols}, though you can do some other
graphical work in it, for example, draw block diagrams.  Schematics
represent electronic circuits, and symbols stand for their logical
blocks such as components or subcircuits.  The connections between the
blocks are represented by @dfn{nets} (wires).  Component symbols can
be obtained either from a standard Lepton @ref{Component libraries, ,
component library}, from some net resources, or created by the user.

After creation, schematics may be printed, converted to several image
formats, including PDF, or exported to several netlist formats for
processing by other tools.

@node Running lepton-schematic, lepton-schematic window, Introduction to lepton-schematic, lepton-schematic
@section Running lepton-schematic
@cindex Running lepton-schematic
@cindex lepton-schematic, running

@schematic{} is a GUI tool, so there are different ways
of running it.  You can launch it from your window manager menu, by
clicking onto an appropriate schematic or symbol icon (@file{.sch} or
@file{.sym}), or from your terminal.  To launch it from menu, look up
for @clicksequence{Development}, @clicksequence{Electronics}, or
@clicksequence{Engineering} submenus.  The last way is most powerful
and versatile.  You can run the command without any arguments just to
open a new, untitled schematic:

@example
lepton-schematic
@end example

or you can specify the names of schematic and symbol files:

@example
lepton-schematic schematic.sch /path/to/symbol.sym
@end example

@schematic{} accepts several @ref{lepton-schematic
command line options, command line options}. Please look the
@code{lepton-schematic(1)} manual page for more information.
Alternatively, run:

@example
lepton-schematic --help
@end example

to get the brief description of all the options supported.

@node lepton-schematic window, Dialog boxes, Running lepton-schematic, lepton-schematic
@section Main lepton-schematic window
@cindex lepton-schematic window
@cindex main lepton-schematic window
@cindex window, lepton-schematic
@cindex main window, lepton-schematic

The window of @schematic{} consists of the following widgets:

@itemize
@item Menubar
@item Toolbar
@item Tabs notebook
@item Drawing area (Page view)
@item Right dock
@item Bottom dock
@item Context menus
@end itemize

@menu
* Menubar::
* Menu File::
* Menu Edit::
* Menu View::
* Menu Page::
* Menu Add::
* Menu Hierarchy::
* Menu Attributes::
* Menu Options::
* Menu Netlist::
* Menu Help::
@end menu

@node Menubar, Menu File, lepton-schematic window, lepton-schematic window
@subsection Menubar
The Menubar widget contains several menus grouped by actions.

@node Menu File, Menu Edit, Menubar, lepton-schematic window
@subsection Menu File
@cindex menu File

@table @emph
@item New

@clicksequence{File @click{} New} (@kbd{Ctrl-N} or @kbd{F N})
allows you to open a new untitled schematic page.  The same as
@clicksequence{Page @click{} New}.

The default page name for new pages is formed as a filename prefix
defined in the configuration key @ref{default-filename} and a serial
number which is incremented every time a new page is created,
e.g. @file{untitled_3.sch}.  Usually, a title block symbol is
inserted, @pxref{Title block symbol}.  A new page is also always
created every time you run @schematic{} without arguments in a
terminal, or from your window manager menu.

@item Open...

@clicksequence{File @click{} Open} (@kbd{Ctrl-O} or @kbd{F O}) opens a
dialog for choosing an existing schematic or symbol file.  Select the
file you need and click the button @samp{Open} to actually open it, or
@samp{Cancel} to cancel with it.  At the bottom-right of the dialog
there is a filter button.  With it, you can change view to see
schematics or symbols only, both schematics and symbols, or any files
in case you want to look at other stuff in the selected directory.

@item Open Recent
@item Save
@item Save As...
@item Save all
@item Print...
@item Write Image...
@item Invoke macro...
@item Execute Script...
@item REPL...
@item New Window
@item Close Window
@item Quit
@end table

@node Menu Edit, Menu View, Menu File, lepton-schematic window
@subsection Menu Edit
@cindex menu Edit

@table @emph
@item Undo
@item Redo
@item Cut
@item Copy
@item Paste
@item Delete
@item Select Mode
@item Select All
@item Deselect
@item Copy Mode
@item Multiple Copy Mode
@item Move Mode
@item Rotate 90 Mode
@item Mirror Mode
@item Object Properties...
@item Edit...
@item Edit Text...
@item Slot...
@item Lock
@item Unlock
@item Embed Component/Picture
@item Unembed Component/Picture
@item Update Component
@item Symbol Translate...
@end table

@node Menu View, Menu Page, Menu Edit, lepton-schematic window
@subsection Menu View
@cindex menu View

@table @emph
@item Find Text Results
@item Redraw
@item Pan
@item Zoom Box
@item Zoom Extents
@item Zoom In
@item Zoom Out
@item Zoom Full
@item Dark Color Scheme
@item Light Color Scheme
@item BW Color Scheme
@item Color Scheme Editor...
@end table

@node Menu Page, Menu Add, Menu View, lepton-schematic window
@subsection Menu Page
@cindex menu Page

@table @emph
@item Manager...
@item Previous
@item Next
@item Close
@item Revert...
@item Next Tab
@item Previous Tab
@end table

@node Menu Add, Menu Hierarchy, Menu Page, lepton-schematic window
@subsection Menu Add
@cindex menu Add

@table @emph
@item Component...
@item Net
@item Bus
@item Attribute...
@item Text...
@item Line
@item Path
@item Box
@item Circle
@item Arc
@item Pin
@item Picture...
@end table

@node Menu Hierarchy, Menu Attributes, Menu Add, lepton-schematic window
@subsection Menu Hierarchy
@cindex menu Hierarchy

@table @emph
@item Up
@item Down Schematic
@item Down Symbol
@end table

@node Menu Attributes, Menu Options, Menu Hierarchy, lepton-schematic window
@subsection Menu Attributes
@cindex menu Attributes

@table @emph
@item Attach
@item Detach
@item Show Value
@item Show Name
@item Show Both
@item Toggle Visibility
@item Hide Specific Text...
@item Show Specific Text...
@item Show/Hide Hidden Text
@item Find Text/Check Symbol
@item Autonumber Text...
@end table

@node Menu Options, Menu Netlist, Menu Attributes, lepton-schematic window
@subsection Menu Options
@cindex menu Options

@table @emph
@item Options...
@item Font...
@item Grid +
@item Grid -
@item Grid Style: Cycle Dots/Mesh/Off
@item Grid Snap: Cycle Grid/Resnap/Off
@item Grips: On/Off
@item Feedback Mode: Outline/Box
@item Net: Rubberband On/Off
@item Net: Magnetic On/Off
@item Coord Window
@item Log Window
@end table

@node Menu Netlist, Menu Help, Menu Options, lepton-schematic window
@subsection Menu Netlist
@cindex menu Netlist

@table @emph
@item 1 allegro
@end table

@node Menu Help,  , Menu Netlist, lepton-schematic window
@subsection Menu Help
@cindex menu Help

@table @emph
@item Lepton EDA Reference Manual
@item gEDA Wiki Documentation
@item Find Component Documentation
@item Hotkeys...
@item About
@end table


@node Dialog boxes, Selecting objects, lepton-schematic window, lepton-schematic
@section Dialog boxes
@cindex dialog boxes
@cindex dialog box

@menu
* Add Component widget::
@end menu

@node Add Component widget,  , Dialog boxes, Dialog boxes
@subsection Add Component widget
@cindex add component widget
@cindex add component dialog box

@node Selecting objects, lepton-schematic command line options, Dialog boxes, lepton-schematic
@section Selecting objects
@cindex selecting objects
@cindex object selection

@menu
* Simple object selection::
* Box selection::
@end menu

@node Simple object selection, Box selection, Selecting objects, Selecting objects
@subsection Simple object selection
@cindex simple object selection

@node Box selection,  , Simple object selection, Selecting objects
@subsection Box selection


@node lepton-schematic command line options, Component libraries, Selecting objects, lepton-schematic
@section lepton-schematic command line options
@cindex lepton-schematic command line options
@cindex lepton-schematic, command-line
@cindex command line options, lepton-schematic


@node Component libraries,  , lepton-schematic command line options, lepton-schematic
@section Component libraries
@cindex component libraries

The global @emph{component library} of a project is made up of a
number of @emph{symbol libraries}, otherwise named @emph{component
resources}, each of which in turn makes available a number of
component @emph{symbols}.  Each resource may be either a directory on
disk containing symbol files, a command in the system @env{PATH} which
can generate symbol data (e.g. from a database), or a Scheme function
which can do likewise.

The component library system in Lepton manages component resources and
symbols, and abstracts the interface to the underlying storage.  The
libraries are used by all Lepton tools based on the code of the
@code{liblepton} library.

A directory which contains one or more symbol files in @ref{gEDA file
format} may be used as a component resource.  Each symbol file should
have a filename ending in @samp{.sym} (case insensitive).  A component
resource based on a directory can be added using the functions
@ref{component-library} or @ref{component-library-search}.  Symbol
files with filenames starting with a period @samp{.} are ignored.

An executable program in the system search path may be used as a
component resource.  A component resource based on a command may
be added using the function @ref{component-library-command}.

Scheme functions may be used as a component resource as well.  A
component resource based on Scheme functions may be added using the
function @ref{component-library-funcs}.

Each symbol is identified by its @emph{name}, which is stored in the
saved schematic file.  The name must be a valid for storage in a
Lepton schematic file as the @emph{basename} of a @emph{component} object.
For symbols from directory resources, the filename of the symbol is
taken as the symbol name.  For a command resource, the name may be any
permissible string.  Guidelines to follow:

@itemize
@item
Do not begin a symbol name with @samp{EMBEDDED}.
@item
Do not use whitespace, or any of the characters @samp{/:!*?}.
@item
Try to use unique names.
@end itemize


@menu
* Component library setup::
@end menu

@node Component library setup,  , Component libraries, Component libraries
@subsection Component library setup

Component library functions are Scheme procedures that should be
specified in one of @file{gafrc} files.  @xref{Legacy configuration}
for more information.

Environment variables are expanded in all component library functions
working with paths.  You can use, e.g. @samp{$@{HOME@}/lib/path} to
specify the directory you need.  You may form the path names with any
Scheme functions available as well.

The following commands are available:

@menu
* component-library::
* component-library-search::
* component-library-command::
* component-library-funcs::
* reset-component-library::
@end menu

@node component-library, component-library-search, Component library setup, Component library setup
@subsubsection component-library
@cindex component-library

The function @code{component-library} defines a directory containing
@emph{symbol} files as a component resource.  You should use it as
follows:

@lisp
(component-library path)
@end lisp
@noindent
or
@lisp
(component-library path name)
@end lisp

@var{path} is a path to the directory you want to add as a component
resource.  Environment variables in @var{path} are expanded.  Using
this function is convenient if you want each of your library to have a
unique descriptive name.  It can be specified with the second argument
@var{name}.  The name is optional, if it is omitted, @var{path} is
used instead.  The name will be displayed in the @samp{Select
component} window of @schematic.  Obviously, it is
useless for CLI Lepton tools.


@node component-library-search, component-library-command, component-library, Component library setup
@subsubsection component-library-search
@cindex component-library-search

The function @code{component-library-search} is similar to
@ref{component-library} as it also defines a component resource from a
directory on disk.  However, it adds all the directories in it
recursively as a tree of several component resources.  This approach
is good when you don't want to list each separate subdirectory in the
root directory.  But then you won't be able to specify unique names
for the subdirectories.

The usage is as follows:

@lisp
(component-library-search path)
@end lisp
@noindent
or
@lisp
(component-library-search path prefix)
@end lisp

Here @var{path} is a root directory from which you want to make a tree
of component resources.  If optional @var{prefix} is specified, it
will be prepended to the names of the new libraries.


@node component-library-command, component-library-funcs, component-library-search, Component library setup
@subsubsection component-library-command
@cindex component-library-command

A program or set of programs can be used as a component resource.  The
procedure used to add such a resource from a Lepton RC file is:

@example
(component-library-command list-command get-command name)
@end example

The code adds a new library named @var{name}.  The @var{list-command}
argument specifies a name of the program that will be executed with no
further arguments, and should output a list of available symbol names
on stdout.  The @var{get-command} argument specifies another program
that should take a symbol name as its only argument, and output symbol
data in @ref{gEDA file format} on stdout.

If the command cannot successfully complete, it should exit with
non-zero exit status.  Anything it has output on stdout will be
ignored, and any stderr output displayed to the user.

This is the contents of an example script:

@example
@include cmd-component.sh
@end example

As can be seen from the code, the script can function as list command,
if the option @option{-l} is given, or as get command, if file name is
given.  Otherwise, if no arguments given, it exits with an error code.
If the script is named, say, @file{cmd-component.sh}, then the
following code in @file{gafrc} file will define a new component
library:

@lisp
(define list-command "cmd-component.sh")
(define get-command (string-append list-command " -l"))
(component-library-command list-command get-command "simple-cmd-lib")
@end lisp

Likewise, you can use various symbol generators written in various
languages.

@node component-library-funcs, reset-component-library, component-library-command, Component library setup
@subsubsection component-library-funcs
@cindex component-library-funcs

A set of Scheme procedures can be used as a component resource.  The
procedure used to add such a resource from a Lepton RC file is:

@lisp
(component-library-funcs list-function get-function name)
@end lisp

@var{list-function} and @var{get-function} must both be Guile
procedures.  @var{list-function} takes no arguments, and returns a
list of symbol names as Scheme strings.  @var{get-function} takes a
symbol name as an argument, and returns symbol data in @ref{gEDA file
format} in a Scheme string, or @code{#f} if not known.  The @var{name}
argument specifies the name of the new library.

Thus, the user may take advantage of using currently available Scheme
procedures for creating schematic objects.  For example:

@lisp
@include scm-component.scm
@end lisp

The code defines three symbols.  You can see that some steps are
automated in the example for the first two of them: creating
attributes and stroke parameter setting for line objects.  Some other
things are obscure though, like @code{toplevel} stuff.  However, this
is how it currently works.

You may also notice that the last symbol, @samp{dummy.sym}, is defined
just as a string in the @ref{gEDA file format}.  You can do so as
well, though either you lose any automation, or you have to deal with
strings instead of Lepton Scheme objects.

Put the code in some file and load it from your @file{gafrc}, e.g.:

@lisp
(primitive-load "scm-component.scm")
@end lisp
@noindent
or put it directly to @file{gafrc}.


@node reset-component-library,  , component-library-funcs, Component library setup
@subsubsection reset-component-library
@cindex reset-component-library

@code{reset-component-library} initializes, i.e. empties the global
component library.  Thus, the user can define a new set of component
resources from scratch.  For example, sometimes it is convenient to
get rid of default symbols in the library window of
@schematic{} and work only with those in your own custom
libraries.

Use the command before other component library commands, such as
@ref{component-library}.

Supposed you want some of your projects to use only special symbol
libraries, then the typical usage is as follows.  First reset all
libraries, then populate the component library with your directories,
e.g.:

@lisp
(reset-component-library)

(component-library-search "$@{HOME@}/lepton/symbols")
@end lisp

The good place to do so is @file{gafrc} in your project's directory.
However, you can also disable default libraries completely by writing
such lines in @file{gafrc} in the directory with your user's settings.
@xref{Legacy configuration} for more information on configuration
paths.
